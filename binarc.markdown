# binarcの仕様

## binarcの概要

binarcは、**汎用的でプラットフォームに依存しないデータ交換のためのバイナリシリアライズ形式**で、木構造で構成された複数の値をシリアライズし、ひとつの書庫（バイト列）として扱います。

### binarcの特長

汎用的でプラットフォームに依存しないデータ交換形式としては、[JSON](http://www.json.org/json-ja.html)や[XML](http://www.techscore.com/tech/XML)、[YAML](http://magazine.rubyist.net/?0009-YAML)、[MessagePack](http://frsyuki.hatenablog.com/entry/20080816/p1)、[Protocol Buffers](http://ja.wikipedia.org/wiki/Protocol_Buffers)などがすでに広まっています。それらに対するbinarcのメリットとしては、以下のような点が挙げられます。

* binarcはバイナリ形式のフォーマットなので、JSONやXML、YAMLなどのテキスト形式のフォーマットと比べて **書庫のサイズが小さく、高速に処理**できます。
* binarcは、 **デシリアライズで動的なメモリ確保を行いません** 。
* binarcは、書庫の中に値のインデックスを持っているので、デシリアライズの際、**書庫の末尾にあるデータまで高速にアクセス**できます。

「**メモリ消費を抑えた高速なデシリアライズ**」が、binarcのコンセプトです。

### binarcの用途

binarcを使用するアプリケーションとしては、主にビデオゲームを想定しています。動的な変更を行わないデータを、アプリケーションが動作する前の開発段階であらかじめシリアライズしておき、アプリケーション動作中の必要な場面で随時デシリアライズして値を取り出す、というような使い方を想定しています。

## binarcの構造

### 書庫の構造

- 書庫は、ワード単位（1ワードは32ビット）で構成されています。
- 書庫の先頭は、64ビットメモリ境界に接している必要があります。
- 書庫の先頭ワードには、0x494e4478（C言語で記述すると'INDx'）が格納されています。
  - 先頭ワードをバイト列として取得した値によって、書庫のエンディアンが判定できます。
    - バイト列が\[0x78, 0x44, 0x4e, 0x49\]なら、リトルエンディアン。
    - バイト列が\[0x49, 0x4e, 0x44, 0x78\]なら、ビッグエンディアン。
- 書庫の2ワード目には、木構造の最上位の値タグが格納されています。
- 書庫の3ワード目以降には、木構造のすべての値が格納されています。

### 値の構造

binarc書庫には、木構造で複数の値が格納されています。格納される値は、以下の3つの要素に分解されます。

* 値の格納形式と格納場所を表す「**値タグ**」
* 値の内容が実際に格納されている「 **値本体**」
* 値の検索に用いる「**値ハッシュ**」

### 値タグの構造

値タグは、32ビットで構成されます。

- 上位4ビットは、値の格納形式。
- 下位28ビットは、値本体を示すインデックス。

|31　　　　28|27　　　　　　　　　0|
|:----------:|:-------------------:|
|値の格納形式|値本体のインデックス |

#### 値の格納形式

binarcでシリアライズした値の格納形式は、以下のように分類されます。

- スカラー型
  - 真偽値
  - 数値型
    - 符号なし整数型
      - 符号なしイミディエイト整数
      - 符号なし32ビット整数
      - 符号なし64ビット整数
    - 負の整数型
      - 符号つきイミディエイト整数
      - 符号つき32ビット整数
      - 符号つき64ビット整数
    - 浮動小数点型
      - IEEE754単精度浮動小数点数
      - IEEE754倍精度浮動小数点数
  - UTF-8文字列
  - 拡張バイト列
- コンテナ型
  - 配列コンテナ
  - 辞書コンテナ

格納形式を表す値は、以下のようになっています。

|格納形式                  |値 |
|:-------------------------|--:|
|真偽値                    |0x1|
|UTF-8文字列               |0x2|
|拡張バイト列              |0x3|
|配列コンテナ              |0x4|
|辞書コンテナ              |0x5|
|符号なしイミディエイト整数|0x6|
|符号なし32ビット整数      |0x7|
|符号なし64ビット整数      |0x8|
|符号つきイミディエイト整数|0x9|
|符号つき32ビット整数      |0xa|
|符号つき64ビット整数      |0xb|
|IEEE754単精度浮動小数点数 |0xc|
|IEEE754倍精度浮動小数点数 |0xd|

#### 数値のシリアライズ

binarcで数値をシリアライズするとき、

- 等価なイミディエイト整数へ数値を変換できる場合は、数値をイミディエイト整数へ変換して格納します。
- 等価な32ビット整数へ数値を変換できる場合は、数値を32ビット整数へ変換して格納します。
- 等価な64ビット整数へ数値を変換できる場合は、数値を32ビット整数へ変換して格納します。
- 等価な単精度浮動小数点数へ数値を変換できる場合は、数値を単精度浮動小数点数へ変換して格納します。
- 等価な倍精度浮動小数点数へ数値を変換できる場合は、数値を倍精度浮動小数点数へ変換して格納します。

上記に当てはまらない数値は、シリアライズできません。

### 値本体の構造

#### 真偽値

- 値本体は、値タグのインデックス部に格納されています。
-- 値タグのインデックス部が0なら、falseです。
-- 値タグのインデックス部が1なら、trueです。
- 値ハッシュは、値タグのインデックス部です。

#### 符号なしイミディエイト整数

- 値本体は、値タグのインデックス部に格納されています。
- 値ハッシュは、値本体から取り出した値をそのまま使います。

#### 符号なし32ビット整数

- 値本体は、binarc書庫の先頭位置を基準位置として、値タグのインデックス部をオフセットワード数とした場所に格納されています。
- 値本体は、1ワードを使って格納されています。
- 値ハッシュは、値本体から取り出した値をそのまま使います。

#### 符号なし64ビット整数

- 値本体は、binarc書庫の先頭位置を基準位置として、値タグのインデックス部をオフセットワード数とした場所に格納されています。
-- 値タグのインデックス部は、必ず偶数となります。
- 値本体は、2ワードを使って格納されています。
- 値ハッシュは、値本体から取り出した値の上位32ビットと下位32ビットで排他的論理和をとったものです。

#### 符号つきイミディエイト整数

- 値本体は、値タグのインデックス部の28ビット以上の値を、1で拡張した値です。
- 値ハッシュは、値本体から取り出した値を、符号なし32ビット整数へ変換したものです。

#### 符号つき32ビット整数

- 値本体は、binarc書庫の先頭位置を基準位置として、値タグのインデックス部をオフセットワード数とした場所に格納されています。
- 値本体は、1ワードを使って格納されています。
- 値ハッシュは、値本体から取り出した値を、符号なし32ビット整数へ変換したものです。

#### 符号つき64ビット整数

- 値本体は、binarc書庫の先頭位置を基準位置、値タグのインデックス部をオフセットワード数とした場所に格納されています。
-- 値タグのインデックス部は、必ず偶数となります。
- 値本体は、2ワードを使って格納されています。
- 値ハッシュは、値本体から取り出した64ビット値の上位32ビットと下位32ビットで排他的論理和をとったものを、符号なし32ビット整数へ変換したものです。

#### IEEE754単精度浮動小数点数

- 値本体は、binarc書庫の先頭位置を基準位置として、値タグのインデックス部をオフセットワード数とした場所に格納されています。
- 値本体は、1ワードを使って格納されています。
- 値ハッシュは、値本体から取り出した32ビット値です。

#### IEEE754倍精度浮動小数点数

- 値本体は、binarc書庫の先頭位置を基準位置、値タグのインデックス部をオフセットワード数とした場所に格納されています。
-- 値タグのインデックス部は、必ず偶数となります。
- 値本体は、2ワードを使って格納されています。
- 値ハッシュは、値本体から取り出した64ビット値の上位32ビットと下位32ビットで排他的論理和をとったものを、符号なし32ビット整数へ変換したものです。

#### UTF-8文字列
#### 拡張バイト列
#### 配列コンテナ
#### 辞書コンテナ

